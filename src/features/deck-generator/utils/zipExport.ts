import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import type { GeneratedDeck } from '../types/deck.types';

export interface ExportProgress {
  current: number;
  total: number;
  status: string;
}

/**
 * Export deck slides as a ZIP file containing PNG images
 * Takes pre-captured slide blobs for reliable export
 */
export async function exportDeckAsZip(
  deck: GeneratedDeck,
  slideBlobs: Blob[],
  onProgress?: (progress: ExportProgress) => void
): Promise<void> {
  const zip = new JSZip();
  const slidesFolder = zip.folder('slides');

  if (!slidesFolder) {
    throw new Error('Failed to create slides folder in ZIP');
  }

  const totalSlides = slideBlobs.length;

  // Add each slide image to the ZIP
  for (let i = 0; i < totalSlides; i++) {
    onProgress?.({
      current: i + 1,
      total: totalSlides,
      status: `Adding slide ${i + 1} to ZIP`
    });

    const slideNumber = String(i + 1).padStart(2, '0');
    slidesFolder.file(`slide-${slideNumber}.png`, slideBlobs[i]);
  }

  // Add deck metadata as JSON
  const metadata = {
    name: deck.templateName,
    generatedAt: deck.generatedAt,
    totalSlides: deck.slides.length,
    generationTimeMs: deck.metadata.generationTimeMs,
    slides: deck.slides.map((slide, index) => ({
      number: index + 1,
      type: slide.type,
      aiGenerated: slide.aiGenerated || false,
      sectionId: slide.sectionId
    }))
  };

  zip.file('deck-info.json', JSON.stringify(metadata, null, 2));

  // Add a simple README
  const readme = `# ${deck.templateName}

Generated: ${new Date(deck.generatedAt).toLocaleString()}
Total Slides: ${deck.slides.length}

## Slides
${deck.slides.map((slide, i) => `${i + 1}. ${slide.sectionId} (${slide.type})${slide.aiGenerated ? ' - AI Generated' : ''}`).join('\n')}

---
Generated by Guardian Intel
`;
  zip.file('README.md', readme);

  onProgress?.({
    current: totalSlides,
    total: totalSlides,
    status: 'Creating ZIP file...'
  });

  // Generate the ZIP file
  const content = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 }
  });

  // Create filename from deck name and date
  const sanitizedName = deck.templateName
    .replace(/[^a-zA-Z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .toLowerCase();
  const dateStr = new Date().toISOString().split('T')[0];
  const filename = `${sanitizedName}-${dateStr}.zip`;

  // Trigger download
  saveAs(content, filename);
}

/**
 * Export a single slide as PNG from a blob
 */
export function exportSlideAsPng(
  blob: Blob,
  slideNumber: number,
  deckName: string
): void {
  const sanitizedName = deckName
    .replace(/[^a-zA-Z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .toLowerCase();
  const filename = `${sanitizedName}-slide-${String(slideNumber).padStart(2, '0')}.png`;
  saveAs(blob, filename);
}
