import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import type { GeneratedDeck } from '../types/deck.types';

export interface ExportProgress {
  current: number;
  total: number;
  status: string;
}

/**
 * Convert base64 string to Blob
 */
function base64ToBlob(base64: string, mimeType: string = 'image/png'): Blob {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}

/**
 * Export deck slides as a ZIP file containing PNG images
 * Takes pre-captured slide blobs for reliable export
 */
export async function exportDeckAsZip(
  deck: GeneratedDeck,
  slideBlobs: Blob[],
  onProgress?: (progress: ExportProgress) => void
): Promise<void> {
  const zip = new JSZip();
  const slidesFolder = zip.folder('slides');

  if (!slidesFolder) {
    throw new Error('Failed to create slides folder in ZIP');
  }

  const totalSlides = slideBlobs.length;

  // Add each slide image to the ZIP
  for (let i = 0; i < totalSlides; i++) {
    onProgress?.({
      current: i + 1,
      total: totalSlides,
      status: `Adding slide ${i + 1} to ZIP`
    });

    const slideNumber = String(i + 1).padStart(2, '0');
    slidesFolder.file(`slide-${slideNumber}.png`, slideBlobs[i]);
  }

  // Add deck metadata as JSON
  const metadata = {
    name: deck.templateName,
    generatedAt: deck.generatedAt,
    totalSlides: deck.slides.length,
    generationTimeMs: deck.metadata.generationTimeMs,
    slides: deck.slides.map((slide, index) => ({
      number: index + 1,
      type: slide.type,
      aiGenerated: slide.aiGenerated || false,
      sectionId: slide.sectionId
    }))
  };

  zip.file('deck-info.json', JSON.stringify(metadata, null, 2));

  // Add a simple README
  const readme = `# ${deck.templateName}

Generated: ${new Date(deck.generatedAt).toLocaleString()}
Total Slides: ${deck.slides.length}

## Slides
${deck.slides.map((slide, i) => `${i + 1}. ${slide.sectionId} (${slide.type})${slide.aiGenerated ? ' - AI Generated' : ''}`).join('\n')}

---
Generated by Guardian Intel
`;
  zip.file('README.md', readme);

  onProgress?.({
    current: totalSlides,
    total: totalSlides,
    status: 'Creating ZIP file...'
  });

  // Generate the ZIP file
  const content = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 }
  });

  // Create filename from deck name and date
  const sanitizedName = deck.templateName
    .replace(/[^a-zA-Z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .toLowerCase();
  const dateStr = new Date().toISOString().split('T')[0];
  const filename = `${sanitizedName}-${dateStr}.zip`;

  // Trigger download
  saveAs(content, filename);
}

/**
 * Export a single slide as PNG from a blob
 */
export function exportSlideAsPng(
  blob: Blob,
  slideNumber: number,
  deckName: string
): void {
  const sanitizedName = deckName
    .replace(/[^a-zA-Z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .toLowerCase();
  const filename = `${sanitizedName}-slide-${String(slideNumber).padStart(2, '0')}.png`;
  saveAs(blob, filename);
}

/**
 * Export deck using pre-generated Nano Banana Pro images when available
 * Falls back to provided blobs for slides without imageData
 */
export async function exportDeckWithImages(
  deck: GeneratedDeck,
  fallbackBlobs?: Blob[],
  onProgress?: (progress: ExportProgress) => void
): Promise<void> {
  const zip = new JSZip();
  const slidesFolder = zip.folder('slides');

  if (!slidesFolder) {
    throw new Error('Failed to create slides folder in ZIP');
  }

  const totalSlides = deck.slides.length;

  // Add each slide image to the ZIP
  for (let i = 0; i < totalSlides; i++) {
    const slide = deck.slides[i];

    onProgress?.({
      current: i + 1,
      total: totalSlides,
      status: `Adding slide ${i + 1} to ZIP${slide.imageData ? ' (Nano Banana Pro)' : ''}`
    });

    const slideNumber = String(i + 1).padStart(2, '0');

    if (slide.imageData) {
      // Use pre-generated Nano Banana Pro image
      const blob = base64ToBlob(slide.imageData, 'image/png');
      slidesFolder.file(`slide-${slideNumber}.png`, blob);
    } else if (fallbackBlobs && fallbackBlobs[i]) {
      // Fall back to html2canvas captured blob
      slidesFolder.file(`slide-${slideNumber}.png`, fallbackBlobs[i]);
    }
  }

  // Add deck metadata as JSON
  const metadata = {
    name: deck.templateName,
    generatedAt: deck.generatedAt,
    totalSlides: deck.slides.length,
    generationTimeMs: deck.metadata.generationTimeMs,
    nanoBananaProSlides: deck.slides.filter(s => s.imageData).length,
    slides: deck.slides.map((slide, index) => ({
      number: index + 1,
      type: slide.type,
      aiGenerated: slide.aiGenerated || false,
      nanoBananaPro: !!slide.imageData,
      sectionId: slide.sectionId
    }))
  };

  zip.file('deck-info.json', JSON.stringify(metadata, null, 2));

  // Add a README with Nano Banana Pro attribution
  const nanoBananaCount = deck.slides.filter(s => s.imageData).length;
  const readme = `# ${deck.templateName}

Generated: ${new Date(deck.generatedAt).toLocaleString()}
Total Slides: ${deck.slides.length}
Nano Banana Pro Visuals: ${nanoBananaCount}

## Slides
${deck.slides.map((slide, i) => `${i + 1}. ${slide.sectionId} (${slide.type})${slide.imageData ? ' - üçå Nano Banana Pro' : slide.aiGenerated ? ' - AI Generated' : ''}`).join('\n')}

---
Generated by Guardian Intel
Visuals powered by Nano Banana Pro (Gemini 3 Pro Image)
`;
  zip.file('README.md', readme);

  onProgress?.({
    current: totalSlides,
    total: totalSlides,
    status: 'Creating ZIP file...'
  });

  // Generate the ZIP file
  const content = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 }
  });

  // Create filename from deck name and date
  const sanitizedName = deck.templateName
    .replace(/[^a-zA-Z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .toLowerCase();
  const dateStr = new Date().toISOString().split('T')[0];
  const filename = `${sanitizedName}-${dateStr}.zip`;

  // Trigger download
  saveAs(content, filename);
}
